### Конструкция match case
```python
def http_error(status):
    match status:
        case 100 | 101:
            print('100')
        case 200:
            print('200')
        case _:
            print('_')

http_error(101)
```
### Аргументы функции
```python
def foo(a, b, /, c, d, *, e, f):
    print(a, b, c, d, e, f)

foo('a', 'b', 'c', 'd', e='e', f='f')
```
### lambda функции
```python
def foo(x):
    return lambda y: y ** x

print(foo(2)(2))
```
### Формат документирования функций
```python
def foo():
    """
    Краткое описание функции с точкой на конце.

    Если есть подробности, то они указываются через пустую строку.
    """
    return

print(foo.__doc__)
```
### Аннотации функций
```python
def foo(a: str) -> str:
    return 'OK'

print(foo.__annotations__)
```
### Использование списков в качестве очередей
Списки можно использовать в качестве очереди, где первый добавленный элемент является первым полученным элементом. Списки неэффективны для этой цели, так как вставка и удаление из начала списка выполняется медленно. Для реализации очереди есть collections.deque.
### Пример использования списков
Способы создания списка:
```python
lst = list(map(lambda x: x**2, range(10)))
```
```python
lst = [x**2 for range(10)]
```
```python
lst = []
for x in range(10):
    lst.append(x**2)
```
Способы транспонирования матрицы
```python
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]
```
```python
[[row[i] for row in matrix] for i in range(4)]
```
```python
transposed = []
for i in range(4):
    transposed.append([row[i] for row in matrix])
```
```python
transposed = []
for i in range(4):
    transposed_row = []
    for row in matrix:
        transposed_row.append(row[i])
    transposed.append(transposed_row)
```
```python
list(zip(*matrix))
```
### del
Удаляет элементы из списка, переменные.
```python
del lst[0]
del lst[:]
del lst[2:3]
del var
```
### Тип данных: Набор
Набор - неупорядоченная коллекция без повторяющихся элементов.
```python
s = {'o', 't', 'th', 'f'}
s = set()
s = {x for x in 'abc' if x not in  'def'}
s1 = set('abc')
s2 = set('def')
s1 - s2
s1 | s2
s1 & s2
s1 ^ s2
```
### Методы работы с циклами
Для перебора словаря в виде ключ-значение используют `dict.items()`. Для перебора списка в виде ключ-значение используют `enumerate(list)`. Для перебора нескольких списков одновременно используют `zip(list1, list2)`. Для перебора обратной последовательности используют `reversed(...)`. Для перебора отсортированной последовательности используют `sorted(...)`.
### Функция dir() 
Возвращает отсортированный список строк имен модуля.
## 3. I/O
### Форматирование вывода
```python
str1 = f'Line {var}'
str2 = '{}'.format(var)
str2 = '{a}'.format(a=var)
str2 = '{0}'.format(var)
str3 = str(var)
str4 = repr(var)
str5 = ('str %i' % 1)
```
Форматированный вывод сгенерированной матрицы указанного размера.
```python
size = 20
matrix = [[j+i*size for j in range(1, size+1)] for i in range(size)]

[print(' '.join([str(j).rjust(len(str(size ** 2))) for j in i])) for i in matrix]
```
### Чтение-запись файлов
Режимы открытия файла: `r` - только для чтения, `w` - только для записи (очищает), `a` - для добавления, `r+` - для чтения и записи. Добавление `b` откроет в двоичном режиме.
```python
f = open(filename, mode='r', encoding=None)
```
Рекомендуется использовать с конструкцией with, файл корректно закроется после завершения работы:
```python
with open('filepath', encoding="utf-8") as f:
    read_data = f.read()
```
Иначе необходимо вручную закрывать файл:
```python
f.close()
```
#### Методы файловых обьектов
##### f.read(size)
Считывает некоторое количество данных и возвращает в виде строки или байтового обьекта. Если size не указан, то будет возвращено все содержимое файла.
##### f.readline()
Считывает одну строку из файла, которая заканчивается \n. Если достигнут конец файла, то возвращается пустая строка.
##### f.readlines()
Все строки файла в списке или list(f).
##### f.write(string)
Записывает строку в файл и возвращает кол-во записанных символов.
##### f.tell()
Возвращает целое число, указывающее текущую позицию файлового обьекта в файле, представленное как кол-во байтов от начала файла в двоичном режиме
##### f.seek(offset, whence)
Изменение положения файлового обьекта. offset - положение, whence - опорная точка (0 - начало файла, 1 - текущая позиция файла, 2 - конец файла). По умолчанию 0.
## Генераторы
При каждом вызове next() генератор возобновляет работу с того места, где остановился (он запоминает все значения данных и то, какой оператор был выполнен последним). Методы __iter__ и __next__ создаются автоматически.
```python
def reverse(data):
    for i in range(len(data)-1, -1, -1):
        yield data[i]

for i in reverse('spam'):
    print(i)
```
## Генераторные выражения
Выражения-генераторы более компактны, но менее универсальны, чем полные определения генераторов, и более удобны для памяти, чем эквивалентные определения списков.
```python
sum(i*i for i in range(10))
```