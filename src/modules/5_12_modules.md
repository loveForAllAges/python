# Параллельное выполнение
1. [threading - Потоковый параллелизм](#1)
2. [multiprocessing - Параллелизм на основе процессов](#2)
3. [concurrent - запуск параллельных задач](#3)
4. [subprocess - Управление подпроцессами](#4)
5. [sched - Планировщик событий](#5)
6. [queue - Класс синхронизированной очереди](#6)
7. [contextvars - Контекстные переменные](#7)
8. [thread - Низкоуровневый API многопоточности](#8)


## <div id="1">1. threading - Потоковый параллелизм</div>
> Модуль предоставляет классы, фукнции и константы для создания и управления потоками выполнения. Потоки - легковесные подпроцессы, которые выполняются параллельно. Необходимо быть осторожным с синхронизацией доступа к общим ресурсам, чтобы избежат проблем с гонками данных. Основная проблема многопоточных приложений - координация потоков, которые совместно используют данные или другие ресурсы
### Использование
- Параллельное выполнение независимых задач.
- Загрузка данных из сети или обработка пользовательского ввода, не блокируя основной поток выполнения программы.
- Создание многозадачных приложений, где различные части программы могут выполняться параллельно.
### Примеры
```python
def my_function():
    for _ in range(5):
        print("Hello from thread")

# Создание потока
my_thread = threading.Thread(target=my_function)

# Запуск потока
my_thread.start()

# Ожидание завершения потока
my_thread.join()

print("Main thread continues...")
```

```python
import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')
background.join()
print('Main program waited until background was done.')
```


## <div id="2">2. multiprocessing - Параллелизм на основе процессов</div>
> Модуль предоставляет классы для создания процессов, взаимодействия между ними и выполнения параллельных вычислений за счет параллелизма. Каждый процесс имеет собственное пространсво памяти, что делает их независимыми друг от друга.
### Использование
- Запуск кода в нескольких процессах для выполнения параллельных вычислений и ускорения выполнения программ.
- Применение параллельных процессов позволяет эффективнее обрабатывать многозадачные приложения, такие как одновременная обработка большого количества данных.
- Распределенное выполнение задач по нескольким ядрам процессора, что повышает производительность.
- Работа с параллельными задачами ввода-вывода.
- Изоляция код и предотвращение конфликтов при работе с данными.
### Примеры
```python
def my_function(arg):
    print(f"Argument passed to process: {arg}")

if __name__ == "__main__":
    # Создание процесса
    my_process = multiprocessing.Process(target=my_function, args=("example",))

    # Запуск процесса
    my_process.start()

    # Ожидание завершения процесса
    my_process.join()
```


## <div id="3">3. concurrent - запуск параллельных задач</div>
> Модуль предоставляет классы для асинхронного выполнения вызываемых обьектов.
### Использование
- Выполнение функций или вызов обьектов параллельно, используя потоки или процессы.
- Поддержка для асинхронного выполнения задач с использованием `asyncio`.
### Примеры
```python
def some_function(arg):
    # Ваш код

# Создание ThreadPoolExecutor с тремя потоками
with concurrent.futures.ThreadPoolExecutor(max_workers=3) as executor:
    # Параллельное выполнение функции с разными аргументами
    results = executor.map(some_function, [arg1, arg2, arg3])
    
    # Результаты будут возвращены в том порядке, в котором задачи были запущены
    for result in results:
        print(result)
```


## <div id="4">4. subprocess - Управление подпроцессами</div>
> Модуль предоставляет функции и классы для создания новых процессов, подключения к их каналам ввода/вывода/ошибок и получеие их кодов возврата. Заменяет модуль `os.system()`.
### Использование
- Запуск внешней команды и ожидание ее завершения.
- Передача данных между скриптом и процессом.
- Выполнение кодман в оболочке.
### Примеры
```python
subprocess.run("echo Hello, subprocess!", shell=True)


process = subprocess.Popen(["echo", "Hello, subprocess!"], stdout=subprocess.PIPE)
output, _ = process.communicate()
print(output.decode())


result = subprocess.run(["ls", "-l"], stdout=subprocess.PIPE)
print(result.stdout.decode())
```


## <div id="5">5. sched - Планировщик событий</div>
> Модуль предоставляет класс для планирования задач в определенное время или через определенные интервалы.
### Использование
- Используется для управления временем выполнения задач в определенные моменты времени.
- Выполнение определенной функции через определенные интервалы времени, создавая периодические задачи.
- Планирование выполнения задач в конкретные моменты времени при автоматизации регулярных процессов.
- Управление порядком выполнения параллельных задач.
### Примеры
```python
def some_task():
    print("Выполнение задачи!")

# Создание объекта планировщика
scheduler = sched.scheduler(time.time, time.sleep)

# Планирование выполнения задачи через 5 секунд
scheduler.enter(5, 1, some_task, ())

# Запуск планировщика
scheduler.run()
```


## <div id="6">6. queue - Класс синхронизированной очереди</div>
> Модуль предоставляет классы для безопасного обмена информацией между несколькими потоками в многопоточном программировании. Реализует очереди с несколькими производителями и несколькими потребителями. Реализует 3 типа очередей, которые отличаются только порядком получения записей (FIFO, LIFO, Приоритетная очередь). FIFO - первые добавленные задачи извлеваются первыми. LIFO - последняя добавленная запись извлекается первой (как стек). Приоритетная запись - записи сортируются (с использованием модуля `heapq`) и первой извлекается запись с наименьшим значением. Используются блокировки для временной блокировки конкурирующих потоков, однако они не предназначены для обработки повторного входа в поток.
### Использование
- Реализация многозадачности, синхронизация потоков или процессов, где несколько задач должны обмениваться данными в безопасном порядке.
### Примеры
```python
# Создание очереди
my_queue = queue.Queue()

# Добавление элементов в очередь
my_queue.put(1)
my_queue.put(2)
my_queue.put(3)

# Извлечение элементов из очереди
print(my_queue.get())  # Вывод: 1
print(my_queue.get())  # Вывод: 2
```


## <div id="7">7. contextvars - Контекстные переменные</div>
> Модуль предоставляет классы и функции для управления, хранения и доступа к локальному состоянию контекста. Контекстные переменные предоставляют способ хранения данных, которые могут быть доступны в пределах определенного контекста выполнения программы.
### Использование
- Передача данных между асинхронными корутинами или в различных частях многозадачного приложения, где нужно сохранять состояние в пределах определенного контекста.
### Примеры
```python
# Создание контекстной переменной
my_var = contextvars.ContextVar('my_var', default='default_value')

def example_function():
    # Установка значения переменной в текущем контексте
    my_var.set('new_value')

    # Получение значения переменной в текущем контексте
    value = my_var.get()
    print(value)

# Вызов функции в новом контексте
with contextvars.copy_context():
    example_function()

# Значение переменной в изначальном контексте остается неизменным
original_value = my_var.get()
print(original_value)
```


## <div id="8">8. _thread - Низкоуровневый API многопоточности</div>
> Модуль предоставляет функции низкого уровня для работы с несколькими потоками - несколькими потоками управления, совместно использующими свое глобальное пространство данных. Модуль `threading` предоставляет более высокий уровень многопоточности.
### Использование
- Аналогично модулю `threading`.
### Примеры
```python
# Функция, которая будет выполняться в отдельном потоке
def print_time(thread_name, delay):
    count = 0
    while count < 5:
        time.sleep(delay)
        count += 1
        print(f"{thread_name}: {time.ctime(time.time())}")

# Создание двух потоков
try:
    _thread.start_new_thread(print_time, ("Thread-1", 2,))
    _thread.start_new_thread(print_time, ("Thread-2", 4,))
except:
    print("Error: Unable to start threads")

# Ждем, пока оба потока завершатся
time.sleep(10)
```

