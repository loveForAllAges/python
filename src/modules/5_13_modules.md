# Сети и межпроцессорное взаимодействие
1. [asyncio - Асинхронный ввод-вывод](#1)
2. [socket - Низкоуровневый сетевой интерфейс](#2)
3. [ssl - Оболочка TLS/SSL для объектов сокетов](#3)
4. [select - Ожидание завершения ввода-вывода](#4)
5. [selectors - Высокоуровневое мультиплексирование ввода-вывода](#5)
6. [signal - Установите обработчики асинхронных событий](#6)
7. [mmap - Поддержка файлов, отображаемых в памяти](#7)


## <div id="1">1. asyncio - Асинхронный ввод-вывод</div>
> Модуль предоставляет фукнции и классы для написания параллельного кода с использованием синтаксиса async/await. 
### Использование
- Низкоуровневый API для разработчиков библиотек.
- Высокоуровневый API для одновременного запуска сопрограмм, выполнения сетевого ввода-вывода, управления подпроцессами, распределения задач по очередям, синхронизации параллельного кода.
- Автоматизация задач, которые зависят от событий, таких как таймеры или изменения состояния.
- Асинхронные подключения к БД позволяют выполнять другие задачи во время ожидания данных.
- Обработка большого количества одновременных веб-запросов без создания большого числа потоков или процессов.
### Примеры
```python
async def hello_world():
    print("Hello")
    await asyncio.sleep(1)
    print("World")

# Создаем цикл событий и запускаем асинхронную функцию
asyncio.run(hello_world())
```


## <div id="2">2. socket - Низкоуровневый сетевой интерфейс</div>
> Модуль предоставляет константы, исключения, функции для работы с сокетами, что позволяет создавать сетевые приложения. Сокеты являются основным механизмом взаимодействия между компьютерами в сети.
### Использование
- Создание сервера, который прослушивает определенный порт и ожидает подключений от клиентов.
- Создание клиентского приложения, которое подключается к серверу по определенному адресу и порту.
- Передача данных между клиентом и сервером.
- Обмен данными без постоянного соединения.
### Примеры
```python
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 8080))
server_socket.listen(5)

while True:
    client_socket, addr = server_socket.accept()


client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client_socket.connect(('localhost', 8080))


client_socket.send(b'Hello, server!')

# Пример получения данных на сервере от клиента
data = client_socket.recv(1024)


udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
udp_socket.sendto(b'Hello, server!', ('localhost', 8080))
```


## <div id="3">3. ssl - Оболочка TLS/SSL для объектов сокетов</div>
> Модуль предоставляет константы, исключения, функции и классы для работы с SSL/TLS (Secure Sockets Layer) протоколами, которые обеспечивают шифрование данных в сети. Использует библиотеку OpenSSL.
### Использование
- Используется для создания защищенных соединений между клиентами и серверами, обеспечивая конфиденциальность и целостность данных, передаваемых по сети.
- Поддержка безопастного соединения HTTPS, обеспечивая защищенную передачу данных между клиентами и серверами.
### Примеры
Создание простого HTTP-сервера, который обеспечивает защищенное соединение с использованием SSL.
```python
from http.server import HTTPServer, SimpleHTTPRequestHandler

# Генерация самоподписанного сертификата (для примера)
httpd = HTTPServer(('localhost', 4443), SimpleHTTPRequestHandler)
httpd.socket = ssl.wrap_socket(httpd.socket, certfile='path/to/server.pem', server_side=True)

# Запуск сервера
httpd.serve_forever()
```


## <div id="4">4. select - Ожидание завершения ввода-вывода</div>
> Модуль предоставляет функции для ожидания возможности чтения или записи в нескольких файловых обьектах (сокетах) одновременно без блокировки выполнения программы.
### Использование
- Используется в сетевом программировании, когда необходимо эффективно управлять множеством сокетов.
### Примеры
Ожидание соединения на серверном сокете и возможность одновременной обработки данных из нескольких клиентских соединений без блокировки выполнения.
```python
server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server_socket.bind(('localhost', 12345))
server_socket.listen(5)

inputs = [server_socket]
outputs = []

while inputs:
    readable, writable, exceptional = select.select(inputs, outputs, inputs)
    
    for s in readable:
        if s is server_socket:
            # Принимаем новое соединение
            connection, address = s.accept()
            inputs.append(connection)
        else:
            # Читаем данные из существующего соединения
            data = s.recv(1024)
            if data:
                # Обрабатываем данные
                print(f"Received data: {data.decode()}")
            else:
                # Соединение закрыто
                inputs.remove(s)
                s.close()
```


## <div id="5">5. selectors - Высокоуровневое мультиплексирование ввода-вывода</div>
> Модуль предоставляет классы, которые обеспечивают многопоточный ввод-вывод, основанный на модуле `select`.
### Использование
- Обеспечение эффективного обработчика событий ввода-вывода без блокировки потоков выполнения. Полезно в асинхронном программировании, где один поток может обрабатывать несколько событий одновременно без блокировки.
### Примеры
Простая реализация эхо-сервера:
```python
sel = selectors.DefaultSelector()

def accept(sock, mask):
    conn, addr = sock.accept()  # Should be ready
    print('accepted', conn, 'from', addr)
    conn.setblocking(False)
    sel.register(conn, selectors.EVENT_READ, read)

def read(conn, mask):
    data = conn.recv(1000)  # Should be ready
    if data:
        print('echoing', repr(data), 'to', conn)
        conn.send(data)  # Hope it won't block
    else:
        print('closing', conn)
        sel.unregister(conn)
        conn.close()

sock = socket.socket()
sock.bind(('localhost', 1234))
sock.listen(100)
sock.setblocking(False)
sel.register(sock, selectors.EVENT_READ, accept)

while True:
    events = sel.select()
    for key, mask in events:
        callback = key.data
        callback(key.fileobj, mask)
```


## <div id="6">6. signal - Установите обработчики асинхронных событий</div>
> Модуль предоставляет классы, переменные, функции для обработки сигналов ОС. Сигналы - уведомления, отправляемые процессам ОС для сообщения о событиях или запроса их завершения.
### Использование
- Реализация корректного завершения программы или выполнения дополнительных действий при получении определенных сигналов.
### Примеры
Ожидание сигнала SIGINT, и если он получен (например, при нажатии на Ctrl+C), будет вызван `handler()`.
```python
def handler(signum, frame):
    print(f"Received signal {signum}")

# Присвоение пользовательского обработчика сигнала SIGINT (Ctrl+C)
signal.signal(signal.SIGINT, handler)

print("Waiting for SIGINT...")
time.sleep(10)
```


## <div id="7">7. mmap - Поддержка файлов, отображаемых в памяти</div>
> Модуль предоставляет константы и классы для работы с отображаемыми в памяти файлами. Позволяет создавать обьекты, представляющие собой отображение файла в виртуальную память.
### Использование
- Отображение файла в память позволяет читать и записывать данные в файл как в обычный буфер в памяти, что ускоряет операции ввода-вывода.
- Обмен данными между процессами, так как отображаемый в памяти файл является разделяемым ресурсом.
- Работа с частями большого файла.
### Примеры
Отображение файла в память:
```python
with open('example.txt', 'r+') as file:
    # Создаем объект mmap для отображения файла в память
    mmapped_file = mmap.mmap(file.fileno(), 0)

    # Теперь можно работать с объектом mmapped_file, как с обычным буфером в памяти

    # Например, чтение первых 10 байт
    data = mmapped_file[:10]

    # Или запись данных в файл
    mmapped_file[10:20] = b'abcdefghij'

    # Не забываем закрыть отображение файла в память
    mmapped_file.close()
```
