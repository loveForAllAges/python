### list
`list` - изменяемая последовательность для хранения коллекций однородных элементов. Списки можно использовать в качестве очереди, где первый добавленный элемент является первым полученным элементом. Списки неэффективны для этой цели, так как вставка и удаление из начала списка выполняется медленно. Для реализации очереди есть collections.deque.
- Поддерживает все методы изменяемых последовательностей.
- Способы создания списка: `[]`, `[a, b, c]`, `[x for x in iterable]`, `list()`.

Методы:
- **`sort`**: сортирует список
```python
l = list(range(2, 9, 2))  # [2, 4, 6, 8]
l[0]  # 2
l[-1]  # 8
l[1]  # 4
l[0:3:2]  # [2, 6]
l[:]  # [2, 4, 6, 8]
l[::-1]  # [8, 6, 4, 2]


[1, 2, 3] + ['A', 'B', 'C']  # [1, 2, 3, 'A', 'B', 'C']
[1, 2] * 2  # [1, 2, 1, 2]


l = ['A', 'B', 'C']
for index, value in enumerate(l):
    print(index, value, sep=': ')
# 0: A
# 1: B
# 2: C


l1 = [1, 2, 3]
l2 = ['A', 'B', 'C']
for item, amount in zip(l1, l2):
    print(item, amount, sep=': ')
# 1: A
# 2: B
# 3: C


'A' in ['A', 'B']  # True
'B' not in ['A', 'B']  # False


a, b, c = ['A', 'B', 'C']  # Распаковка списка


letters = ['a', 'z', 'A', 'Z']
letters.sort(key=str.lower)  # ['a', 'A', 'z', 'Z']


lst = list(map(lambda x: x**2, range(10)))

lst = [x**2 for range(10)]

lst = []
for x in range(10):
    lst.append(x**2)


# Способы транспонирования матрицы
matrix = [
    [1, 2, 3, 4],
    [5, 6, 7, 8],
    [9, 10, 11, 12],
]

[[row[i] for row in matrix] for i in range(4)]

transposed = []
for i in range(4):
    transposed.append([row[i] for row in matrix])

transposed = []
for i in range(4):
    transposed_row = []
    for row in matrix:
        transposed_row.append(row[i])
    transposed.append(transposed_row)

list(zip(*matrix))


# Форматированный вывод сгенерированной матрицы указанного размера:
size = 20
matrix = [[j+i*size for j in range(1, size+1)] for i in range(size)]

[print(' '.join([str(j).rjust(len(str(size ** 2))) for j in i])) for i in matrix]
```


### tuple
`tuple` - неизменяемая последовательность для хранения коллекций разнородных данных.
- Основное отличие кортежей от списков заключается в том, что кортежи, как и строки, неизменяемы.
- Способы создания кортежа: `()`, `a,`, `(a,)`, `a, b, c,`, `(a, b, c)`, `tuple()`.
```python
furniture = ('table', 'chair', 'rack', 'shelf')
furniture[0]  # 'table'
furniture[1:3]  # ('chair', 'rack')
len(furniture)  # 4
```


### dict
`dict` - изменяемое сопоставление хешируемых значений с произвольными обьектами.
- Ключи словаря должны быть хешируемы.
- Способы создания: `{'key': 'value'}`, `{}`, `{x: x for x in range(10)}`, `dict()`, `dict(key='value')`, `dict([('key', 'value')])`.
```python
d = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}


# Операции словаря
list(d)  # Возвращает список всех ключей словаря.
len(d)  # Возвращает количество элементов в словаре.
d['key']  # Возвращает элемент из словаря по ключу, иначе `KeyError`.
d['key'] = 'value'  # Устанавливает значение в словарь.
del d['key']  # Удаляет элемент из словаря по ключу, иначе `KeyError`.
'key' in d  # Существует ли у словаря ключ `key`, иначе `False`.
'key' not in d  # Отсутствует ли у словаря ключ `key`, иначе `False`.
iter(d)  # Возвращает итератор по ключам словаря.
d.clear()  # Очищает словарь.
d.copy()  # Возвращает неполную копию словаря.
d.fromkeys(iterable, value)  # Создает новый словарь с ключами из iterable и значениями из value.
d.get('key', default) # Возвращает значение по ключу, иначе `default`.
d.items()  # Возвращает новое представление элементов словаря в виде `((key, value), ...)`.
d.keys()  # Возвращает новое представление ключей словаря.
d.pop(key, default)  # Удаляет и возвращает значение по ключу, иначе `default`, по умолчанию `KeyError`.
d.popitem()  # Удаляет и возвращает пару из словаря в виде `(key, value)`, иначе `KeyError`.
d.reversed()  # Возвращает обратный итератор по ключам словаря.
d.setdefault(key, default)  # Возвращает значение по ключу, если `key` есть в словаре, иначе вставляет ключ со значением `default` и возвращает значение. По умолчанию `None`.
d.update(other)  # Обновляет словарь парами ключ/значение из `other`, перезаписывая существующие ключи.
d.values()  # Возвращает новое представление значений словаря.
d | other  # Создает новый словарь с обьединенными ключами и значениями.
d |= other  # Обновляет словарь `d` ключами и значениями из `other`.
{**d1, **d2}  # Объединение двух словарей.
```


### set
`Множество` - неупорядоченная коллекция хешируемых обьектов. Используется для удаления дубликатов и математических операций (пересечение, обьединение, разность, симметрическая разность). Не записывает положение элемента, порядок вставки, индексирование и другое поведение последовательностей. 
`set` - изменяемый, не имеет хеша, не может использоваться как ключ словаря и элемент другого сета.

#### Способы создания set
`{'first', 'second'}`, `set()`, `{i for i in 'abcda'}`, `set('content')`, `set(['a', 'b', 'c'])`.
```python
s = {1, 2, 3, 2, 3, 4}  # {1, 2, 3, 4}


# Общие методы для set и frozenset:
len(s)  # Возвращает количество элементов в сете s.
x in s  # Наличие x в s.
x not in s  # Отсутствие x в s.
s.isdisjoint(other)  # Отсутствует ли other в s.
s.issubset(other)  # Является ли s частью other.
s <= other  # Находится ли каждый элемент s в other.
s < other  # Является ли s подмножеством other.
s.issuperset(other)  # Является ли s суперсетом для other.
s > other  # Является ли s подходящим надмножеством other.
s.union(*others)  # Возвращает set со всеми элементами.
s | other  # Возвращает set со всеми элементами.
s.intersection(*others)  # Возвращает set с общими элементами.
s & other  # Возвращает set с общими элементами.
s.difference(*others)  # Возвращает set с элементами, уникальными для s.
s - other  # Возвращает set с элементами, уникальными для s.
s.symmetric_difference(other)  # Возвращает set с элементами, которые не являются общими для наборов.
s ^ other  # Возвращает новый set с элементами одного из сетов.
s.copy()  # Возвращает неглубокую копию сет.


# Методы только для set:
s.update(*others)  # Добавление others в s.
# Или
s |= other | ...

s.intersection_update(*others)  # Обновляет s, сохраняя только общие элементы.
# Или
s &= other & ...

s.difference_update(*others)  # Обновляет s, удаляя одинаковые элементы.
# Или
s -= other | ...

s.symmetric_difference_update(other)  # Обновляет s, сохраняя только уникальные элементы из каждого сета.
# Или
s ^= other

s.add(elem)  # Добавляет elem в s.
s.remove(elem)  # Удаляет elem из s, иначе KeyError.
s.discard(elem)  # Удаляет elem из s без ошибок.
s.pop()  # Удаляет и возвращает произвольный элемент из s, иначе `KeyError`.
s.clear()  # Очищает s.
```


### frozenset
`frozenset` - неизменяемая последовательность, имеет хэш, может использоваться как ключ словаря или элемент другого сета. Содержимое нельзя изменить после создания. Поддерживает общие методы `set`.


### bytes
`bytes` - неизменяемые последовательности отдельных байтов. Байтовые литералы поддерживают только символы ASCII. Две шестандцатеричные цифры соответствуют одному байту. Поддерживает строчные методы.
- Способы создания: `b'string'`, `b"string"`, `b'''string'''`, `bytes(10)`, `bytes(range(20))`.

Методы:
- **`fromhex(string)`**: Возвращает обьект `bytes`, декодируя `string`. `string` должна содержать две шестандцатеричные цифры на байт, пробелы игнорируются.
- **`hex(sep, bytes_per_sep)`**: Возвращает строковый обьект, содержащий две шестандцатеричные цифры для каждого байта. `sep` - разделитель, `bytes_per_sep` - управляет интервалом (положительные значения вычисляют положение справа, отрицательные - слева).


### byteaarray
`bytearray` - изменяемый аналог `bytes`, поддерживает изменяемые операции с последовательностями. Поддерживает строчные методы.
- Способы создания: `bytearray()`, `bytearray(10)`, `bytearray(b'Hi')`.

Методы:
- **`fromhex(string)`**: Возвращает обьект `bytearray`, декодируя `string`. `string` должна содержать две шестандцатеричные цифры на байт, пробелы игнорируются.
- **`hex(sep, bytes_per_sep)`**: Возвращает строковый обьект, содержащий две шестандцатеричные цифры для каждого байта. `sep` - разделитель, `bytes_per_sep` - управляет интервалом (положительные значения вычисляют положение справа, отрицательные - слева).


### memoryview
`memoryview` - обьект, который обеспечивает доступ к буферу памяти с данными. Позволяет работать с данными в памяти без копирования. Эффективно при обработке больших данных (изображения, аудио и т.д.).
- Способы создания: `memoryview(b'abc')`.

Методы:
- **`__eq__(exporter)`**: Эквивалентно, если все соответствующие значения равны.
- **`tobytes(order='C')`**: Возвращает данные в буфер в виде байтовой строки. Эквивалентно `bytes()`.
- **`hex([sep[, bytes_per_sep]])`**: Возвращает строковый обьект, содержащий две шестандцатеричные цифры для каждого байта в буфере.
- **`tolist()`**: Возвращает данные в буфер в виде списка элементов.
- **`toreadonly()`**: Возвращает версию обьекта, доступную только для чтения.
- **`release()`**: Освобождает базовый буфер. Помогает снять запрет на изменение размера и т.д.
- **`cast(format[, shape])`**: Приводит представление в памяти к новому формату или форме.
- **`obj`**: Базовый обьект.
- **`nbytes`**: Обьем пространства в байтах для использования в непрерывном представлении.
- **`readonly`**: Доступна ли память только для чтения.
- **`format`**: Формат для каждого элемента представления.
- **`itemsize`**: Размер в байтах каждого элемента.
- **`ndim`**: Количество представлений памяти измерениями многомерного массива.
- **`shape`**: Кортеж целых чисел, длина которого определяет форму памяти в виде массива.
- **`strides`**: Кортеж целых чисел, длина которого определяет размер в байтах для доступа к каждому элементу для каждого измерения массива.
- **`suboffsets`**: Используется внутри массивов в стиле PIL.
- **`c_contiguous`**: Является ли память C непрерывной.
- **`f_contiguous`**: Является ли память смежной в формате Fortran.
- **`contiguous`**: Является ли память смежной.


### string
`string` - неизменяемая последовательность кодовых символов Юникода.
- Способы создания: `'string'`, `"string"`, `"""string"""`.

Методы:
- **`capitalize`**: Возвращает копию строки с первым символом в верхнем регистре и остальными в нижнем регистре.
- **`casefold`**: Возвращает копию строки в нижнем регистре.
- **`center`**: Возвращает отцентрированную строку.
- **`count`**: Возвращает количество непересекающихся вхождений.
- **`encode`**: Возвращает строку закодированную в bytes.
- **`endswith`**: Заканчивается ли строка определенным символом.
- **`expandtabs`**: Возвращает копию строки, в которой все символы табуляции заменены одним или несколькими пробелами.
- **`find`**: Возвращает индекс первого совпадения искомого.
- **`format`**: Выполняет форматирование строки по фигурным скобкам.
- **`format_map`**: Аналогично `format`, но используется `mapping`, а не копируется в `dict`. Полезно, если `mapping` это подкласс `dict`.
- **`index`**: Аналогично `find`, но может вызвать ошибку.
- **`isalnum`**: Является ли строка буквами или цифрами и есть хотя бы один символ. Символ является буквенно-цифровым, если верно одно из: `c.isalpha()`, `c.isdecimal()`, `c.isdigit`, `c.isnumeric()`.
- **`isalpha`**: Являются ли все символы строки буквами и есть хотя бы один символ.
- **`isascii`**: Является ли строка пустой или все символы являются ASCII.
- **`isdecimal`**: Являются ли все символы в строке десятичными символами и есть хотя бы один символ.
- **`isdigit`**: Являются ли все символы в строке цифрами и есть хотя бы один символ.
- **`isidentifier`**: Является ли строка допустимым индентификатором.
- **`islower`**: Являются ли все символы строки нижнего регистра и есть хотя бы один символ.
- **`isnumeric`**: Являются ли все символы строки числами и есть хотя бы один символ.
- **`isprintable`**: Являются ли все символы строки печатыемые или строка пустая.
- **`isspace`**: Содержит ли строка только пробельные символы и есть хотя бы один символ.
- **`istitle`**: Следуют ли символы верхнего регистра за символами без регистра, а символы нижнего регистра только за символами с регистром и содержит хотя бы один символ.
- **`isupper`**: Имеют ли все символы в строке верхний регистр и есть хотя бы один символ.
- **`join`**: Возвращает строку, которая содержит соединенные строки.
- **`ljust`**: Возвращает строку указанной длины, выровненную по левому краю, с заполненным пространством.
- **`lower`**: Возвращает копию строки нижнего регистра.
- **`lstrip`**: Возвращает копию строки с удаленными начальными символами.
- **`maketrans`**: Возвращает таблицу перевода для `translate`.
- **`partition`**: Разделяет строку при первом появлении символа-разделителя.
- **`removeprefix`**: Возвращает урезанную с начала копию строки.
- **`removesuffix`**: Возвращает урезанную с конца копию строки.
- **`replace`**: Возвращает копию строки с заменными символами.
- **`rfind`**: Возвращает наибольший индекс совпадения в строке.
- **`rindex`**: Аналогично `rfind`, но может вызвать ошибку.
- **`rjust`**: Возвращает строку указанной длины, выровненную по правому краю, с заполнным простанством.
- **`rpartition`**: Разделяет строку по последнему совпадению.
- **`rsplit`**: Возвращает список слов в строке, разделенных с помощью строки-разделителя справа налево.
- **`rstrip`**: Возвращает копию строки с удаленными конечными символами.
- **`split`**: Возвращает список слов в строке, разделенных с помощью строки-разделителя.
- **`splitlines`**: Возвращает список строк в строке, разрывающихся на границах строк.
- **`startswith`**: Начинается ли строка с определенного символа.
- **`strip`**: Возвращает копию строки с удаленными начальными и конечными символами.
- **`swapcase`**: Возвращает копию строки с символами верхнего регистра в нижнем регистре и наоборот.
- **`title`**: Возвращает копию строки, где слова начинаются с верхнего регистра, а последующие символы нижнего регистра.
- **`translate`**: Возвращает копию строки, где каждый символ сопоставлен с помощью таблицы перевода.
- **`upper`**: Возвращает копию строки в верхнем регистре.
- **`zfill`**: Возвращает копию строки, заполненную '0', чтобы создать строку определенной длины.
```python
greet = 'Hello world!'
greet.upper()  # 'HELLO WORLD!'
greet.lower()  # 'hello world!'
greet.title()  # 'Hello World!'

spam = 'Hello world!'
spam.islower()  # False
spam.isupper()  # False

'abc123'.startswith('abcdef')  # False
'abc123'.endswith('12')  # False

'ABC'.join(['My', 'name', 'is', 'Simon'])  # 'MyABCnameABCisABCSimon'

' My  name is  Simon'.split(' ')  # ['', 'My', '', 'name', 'is', '', 'Simon']

'Hello'.rjust(20, '*')  # '***************Hello'
'Hello'.ljust(20, '-') # 'Hello---------------'
'Hello'.center(20, '=')  # '=======Hello========'

spam = '    Hello World     '
spam.strip()  # 'Hello World'
spam.lstrip()  # 'Hello World     '
spam.rstrip()  # '    Hello World'

sentence = 'one sheep two sheep three sheep four'
sentence.count('sheep')  # 3
sentence.count('e')  # 9
sentence.count('e', 6)  # 8
sentence.count('e', 7)  # 7

sentence = "I like apples, Apples are my favorite fruit"
sentence.replace("apples", "oranges")  # 'I like oranges, Apples are my favorite fruit'


'I have %d apples' % 10
'Hello %s' % 'Ivan'
"Hello I'm {}, my age is {}".format('Ivan', 10)
f'Hello {name}!'
(
    'Hello'
    'World'
)  # Многостроность
f"{name.upper() = :-^20}"  # 'name.upper() = -------ROBERT-------'
f"{name.upper() = :^20}"  # 'name.upper() =        ROBERT       '
f"{name.upper() = :20}"  # 'name.upper() = ROBERT              '

# Добавление разделителя тысяч
a = 10000000
f"{a:,}"  # '10,000,000'
# Округление
a = 3.1415926
f"{a:.2f}"  # '3.14'
# Отображение в процентах
a = 0.816562
f"{a:.2%}"  # '81.66%'
```


### int
`int` реализует абстрактный базовый класс numbers.Integral.
- **`bit_length`**: Возвращает количество бит целого числа в двоичном формате, исключая знак и ведущие нули.
- **`bit_count`**: Возвращает количество единиц в двоичном представлении абсолютного значения целого числа.
- **`to_bytes`**: Возвращает массив байт, представляющий целое число. - **`from_bytes`**: Возвращает целое число, представленное заданным массивом байтов.
- **`as_integer_ratio`**: Возвращает пару целых чисел, отношение которых равно исходному целому числу и имеет положительный знаменатель.
- **`is_integer`**: Является ли объект целым числом.


### float
`float` реализует абстрактный базовый класс numbers.Real.
- **`as_integer_ratio`**: Возвращает пару целых чисел, отношение которых точно равно исходному числу с плавающей запятой.
- **`is_integer`**: Является ли целым числом.
- **`hex`**: Возвращает представление числа в виде шестнадцатеричной строки.
- **`fromhex`**: Метод класса для возврата числа с плавающей запятой, представленного шестнадцатеричной строкой s.


### complex
Комплексные числа имеют действительную и мнимую часть, каждая из которых представляет собой число с плавающей запятой. Чтобы извлечь эти части из комплексного числа z, используйте z.real и z.imag.


### bool
Логические значения представляют значения истинности True или False. Является подклассом int.
